<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Raytracer</title>
</head>
<body>
<canvas id='my-canvas'><canvas>

<script src='math/vector3.js'></script>
<script src='math/ray.js'></script>
<script src='math/sphere.js'></script>
<script src='math/plane.js'></script>
<script>

// Canvas setup, don't need to anything in this section ************************
// Get a reference to the javascript object associated with the canvas
var canvas = document.getElementById('my-canvas');

// The canvas dimension we will set
var pixelsAcross = 256;  // pixels across
var pixelsDown = 256; // pixels down

// Set dimensions and pixel scale (generally you can ignore pixelScale, it won't affect your maths)
var pixelScale = 3;
canvas.width = pixelsAcross;
canvas.height = pixelsDown;
canvas.style.cssText = 'width:' + (pixelsAcross * pixelScale) + 'px;height:' + (pixelsDown * pixelScale) + 'px';

// Get the context from the canvas (in this case we just want 2d)
var canvasContext = canvas.getContext('2d');

// Get an array representing all of the pixels
// Arranged left to right, top to bottom
var imageData = canvasContext.getImageData(0, 0, pixelsAcross, pixelsDown);
// end canvas setup section *****************************************************


// Raytracer scene data setup
var fov = 45;   // if this changes, your code should still work
var fovRadians=fov*(Math.PI/180); // todo -> convert degrees to radians (degrees * (pi/180))

var pixelWidth=2/pixelsAcross; // todo -> what's the size of a pixel from left to right?
var pixelHalfWidth=pixelWidth/2; // todo -> half of the pixel width // pixel quadrant

// How far away (scalar) the eye is from the image plane (see project guide for more info)
var eyeDistance=1/(Math.tan(fovRadians/2)); // = todo -> hint: related to tangent and field of view
// -----------
// |         /
// |        /
// |       /
// | 45/2 /      <---- half angle
// |     /
// |    /
// |   /
// |  /
// | /

// important vectors
var eyeCoordinate = new Vector3(0, 0, eyeDistance); // all of your rays will use this

// Define the scene objects here ------------------

// These are 3d definitions that match all of the math we did in class
// They also provide a "raycast" function that you can pass a ray to
// in order to find intersection between the ray and the object

var sphere= new Sphere(new Vector3(0,0,0),.25); // todo = new Sphere(..., ...);
var plane= new Plane(new Vector3(0,1,0),new Vector3(0,-.25,0)); // todo = new Plane(..., ...);
var leftWall = new Plane(new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(1,0,0));
var rightWall = new Plane(new Vector3(-1,0,0),new Vector3(1,0,0),new Vector3(0,1,0));
var ceiling = new Plane(new Vector3(0,-1,0),new Vector3(0,1,0));
var backWall = new Plane(new Vector3(0,0,1),new Vector3(0,0,-1));

var scene = [sphere,plane,leftWall,rightWall,ceiling,backWall];

var lightposition = new Vector3(1,0,0);
var closestobject ={myObject:null,result:{distance:Infinity}};
var resultraycast =0;
var currentObject = 0;
//currentobject goes in foreachloop
// var resultraycast =currentObject.raycast;


//intersection of point to the light(direction of it,normalized vector), and the surface normal vector 
//calculation 
//setPixelColor(xPixelIndex,yPixelIndex,normalDotLight)
// end of raytracer setup ******************************************************

// -----------------------------------------------------------------------------
// return a ray that goes from the eye point through the pixel at index (xPixelIndex, yPixelIndex)
function generateRayForPixel(xPixelIndex, yPixelIndex) {
	var pixelX = -1 + pixelHalfWidth + pixelWidth * xPixelIndex;
	var pixelY = 1 - pixelHalfWidth - pixelWidth * yPixelIndex;
	var pixelCoordinate = new Vector3(pixelX, pixelY, 0);

	var direction=pixelCoordinate.clone().subtract(eyeCoordinate); // = vector from the eye to the pixel to - from 

	// Creates a ray from the eye toward the pixelCoordinate
	var pixelRay=new Ray(eyeCoordinate.clone(),direction.clone()); // = new Ray(...);
	return pixelRay;
}

// -----------------------------------------------------------------------------
function setPixelColor(xPixelIndex, yPixelIndex, color /*[0,1]*/) {
	var index = (yPixelIndex * pixelsAcross + xPixelIndex) * 4; // 4 bytes per pixel
	imageData.data[index + 0] = color.x * 255; // red channel
	imageData.data[index + 1] = color.y * 255; // green channel
	imageData.data[index + 2] = color.z* 255; // blue channel
	imageData.data[index + 3] = 255;
}

// -----------------------------------------------------------------------------
function updateAndRender(timeElapsed) {
	var seconds = timeElapsed *0.001;
	lightposition.x = Math.cos(seconds)*0.5;
	lightposition.z=Math.sin(seconds) *0.5;
  // Go through every pixel
  // NOTE! You should only call setPixelColor once per pixel.  Otherwise, the
  // last time you call it will be the color and overwrite previous calls.

	for (var yPixelIndex = 0; yPixelIndex < pixelsDown; ++yPixelIndex) {
		for (var xPixelIndex = 0; xPixelIndex < pixelsAcross; ++xPixelIndex) {
			
	
			//normal intersection for plane and sphere 
			// Uncomment this once you've coded generateRayForPixel
			var pixelRay = generateRayForPixel(xPixelIndex, yPixelIndex);
			var closestobject =0;
			var resultraycast =0;
			var distanceobject = Infinity;

			// var sphereResult = sphere.raycast(pixelRay);
			// var planeResult = plane.raycast(pixelRay);
			// var leftWallResult = leftWall.raycast(pixelRay);
			// var rightWallResult = rightWall.raycast(pixelRay);
			// var ceilingResult = ceiling.raycast(pixelRay);
			// var backWallResult = backWall.raycast(pixelRay);
					// //to-from
			//new ray to tell if shadow or not
			//create new raycast for shadow
			//direction is lightpointtofrom-intersection
			var shadow = 0;
			//increase distance slightly=offset
			var lightpointtofrom=0;
			//cos theta is dotproductof2vectors
			var dotproductof2vectors=0;
			//shade that objects should be set to 
			var normalDotLight=0;
			//figure out which object is closest in the for loop 
			//object.raycast(pixelRay)
// if(hit & object.raycast.distance < currClosestObject.distance
// sphere.raycast
// plane.raycast
			//currentObject = scene;
	
			for(var i = 0; i<scene.length; i++){
				resultraycast = scene[i].raycast(pixelRay);
				//currentObject = scene;
				
				if(resultraycast.hit==true){
					if(resultraycast.distance<distanceobject){
						
						closestobject = scene[i];
						distanceobject = resultraycast.distance;
					}
			
				}
			}
			var resultofclosestobject = closestobject.raycast(pixelRay);
			lightpointtofrom=lightposition.clone().subtract(resultofclosestobject.point);
			dotproductof2vectors=resultofclosestobject.normal.clone().dot(lightpointtofrom.clone().normalize());
			normalDotLight=dotproductof2vectors;
			setPixelColor(xPixelIndex,yPixelIndex,closestobject.color.clone().multiplyScalar(normalDotLight));
			shadow =new Ray(resultofclosestobject.point,(lightposition.clone().subtract(resultofclosestobject.point)));
					var shadowsphere=sphere.raycast(shadow);
					if(shadowsphere.hit == true){
						if(lightpointtofrom.length()>(shadowsphere.point.clone().subtract(resultofclosestobject.point)).length()){
					setPixelColor(xPixelIndex,yPixelIndex,0);
					}
				}
			// See if the ray intersects the sphere or the plane (or every object in our scene)
		
			//do if statetments or put into global variable 
			//check for closest object 
			//if(hit){ 
//   if(not in shadow){
	//        find what lit color we need
//   else {
//        set to black
// }
// else {
// set to gray

	
			//if costheta =1 surface directly faces the light sourc =fully lit
			//if costheta <=0 surface points away from light source not lit at all (self shadow)
			//if 0<costheta<1 surface is somewhere in between = partially lit
			
			// determine which hit object is the closest (in case there is more than 1 hit)

			// //if we hit something 
			// 	 if(sphereResult.hit==true && planeResult.hit==true){
			// 	// 	//if sphere result.distance < planresult.distance then .8 otherwise .5
			// 		if(sphereResult.distance<planeResult.distance){
			// 			lightpointtofrom=lightposition.clone().subtract(sphereResult.point);
			// 			dotproductof2vectors=sphereResult.normal.clone().dot(lightpointtofrom.clone().normalize());
			// 			normalDotLight=dotproductof2vectors;
			// 			setPixelColor(xPixelIndex,yPixelIndex,normalDotLight);
			// 		}else{
			// 			lightpointtofrom=lightposition.clone().subtract(planeResult.point.clone());
			// 			dotproductof2vectors=planeResult.normal.clone().dot(lightpointtofrom.clone().normalize());
			// 			normalDotLight=dotproductof2vectors;
			// 			setPixelColor(xPixelIndex,yPixelIndex,normalDotLight);					
			// 		}
			// 	}
			// 	//check to see if the sphere is hit then check to see if  sphere is between the intersection point and the light point
			// 	//
			// 	if(sphereResult.hit==true){
			// 		// shadow=new Ray(sphereResult.point,(lightposition.clone().subtract(sphereResult.point)));
			// 		// if(sphere<sphereResult.distance && sphere<lightposition.distance){
			// 		// 	lightpointtofrom =lightposition.clone().subtract(shadow.point);
			// 		// 	dotproductof2vectors =shadow.normal.clone().dot(lightpointtofrom.clone().normalize());
			// 		// 	setPixelColor(xPixelIndex,yPixelIndex,dotproductof2vectors);
			// 		// }
			// 			lightpointtofrom=lightposition.clone().subtract(sphereResult.point);
			// 			dotproductof2vectors=sphereResult.normal.clone().dot(lightpointtofrom.clone().normalize());
			// 			normalDotLight=dotproductof2vectors;
			// 			setPixelColor(xPixelIndex, yPixelIndex, normalDotLight);
					
			// 	} // middle gray
			// 	else if(planeResult.hit==true){
			// 		// if(plane<planeResult.distance && plane<lightposition.distance){
			// 		// 	shadow = new Ray(planeResult.point,(lightposition.clone().subtract(planeResult.point)));
			// 		// 	lightpointtofrom = lightposition.point.subtract(shadow.point);
			// 		// 	dotproductof2vectors =shadow.normal.clone().dot(lightpointtofrom.clone().normalize());
			// 		// 	setPixelColor(xPixelIndex,yPixelIndex,normalDotLight);
			// 		// }
			// 		lightpointtofrom=lightposition.clone().subtract(planeResult.point.clone());
			// 		dotproductof2vectors=planeResult.normal.clone().dot(lightpointtofrom.clone().normalize());
			// 		normalDotLight=dotproductof2vectors;
			// 		setPixelColor(xPixelIndex,yPixelIndex,normalDotLight);
			// 		shadow =new Ray(planeResult.point,(lightposition.clone().subtract(planeResult.point)));
			// 		var shadowsphere=sphere.raycast(shadow);
			// 		if(shadowsphere.hit == true){
			// 			if(lightpointtofrom.length()>(shadowsphere.point.clone().subtract(planeResult.point)).length()){
			// 				setPixelColor(xPixelIndex,yPixelIndex,0);
			// 			}
			// 		}
			//   }
			//    else {
			// 	// we didn't hit anything, choose an appropriate backbround color
			// 	setPixelColor(xPixelIndex, yPixelIndex, 0.1); // dark gray
			//  }
			
		}
	}

	// Take our array of color data and give to the canvas to display
	canvasContext.putImageData(imageData, 0, 0);

	// Let the browser know it should call this function again when it's time to render
	requestAnimationFrame(updateAndRender);
}

// We are ready to render, let the browser know
requestAnimationFrame(updateAndRender);

</script>
</body>
</html>